#!/bin/bash

# Basic vars
NAME=fencoder
OPERATION=""
VIDFILE=""
VERBOSE=0

# Encoding vars
SETTINGS_CROP=""

# HDR vars
FOUND_DOVI=0
FOUND_HDR10=0
FOUND_HDR10PLUS=0
HDR_PIXEL_FORMAT=''
HDR_COLOR_SPACE=''
HDR_COLOR_PRIMARIES=''
HDR_COLOR_TRANSFER=''

# HDR vars

# Print help
print_help() {
    echo "Usage: ${NAME} COMMAND FILE"
    echo
    echo "Commands:"
    echo "  analyze           Analyzes the video file & generates encoding options"
    echo "  encode            Encodes the video file"
}

# Grab CLI opts
set +e
options=$(
    getopt -n ${NAME} \
        -o hv \
        --long help,verbose \
        -- "$@"
)
[ $? -eq 0 ] || {
    echo ; print_help
    exit 1
}
eval set -- "$options"
while true; do
    case $1 in
        -h|--help) print_help ; exit ;;
        -v|--verbose) VERBOSE=1 ; shift ; break ;;
        --) shift ; break ;;
        *) break ;;
    esac
    shift
done

# Grab & check args
OPERATION="$1"
VIDFILE="$2"
if [ "$OPERATION" == "" ]; then
    echo "Please specify a command"
    echo
    print_help
    exit 1
fi
if [ "$OPERATION" != "encode" ] && \
    [ "$OPERATION" != "analyze" ]
then
    echo "${OPERATION}: unknown command"
    echo
    print_help
    exit 1
fi

# Check file
check_file() {
    if [ "$VIDFILE" == "" ]; then
        echo "Please specify a video file"
        exit 1
    fi
    if [ ! -f "$VIDFILE" ]; then
        echo "${VIDFILE}: file not found"
        exit 1
    fi
}

# Check tool requirements
check_requirements() {
    set +e
    which hdr10plus_tool dovi_tool ffmpeg jq >/dev/null
    if [ $? -ne 0 ]; then
        echo "Install required tools:"
        echo "  hdr10plus_tool"
        echo "  dovi_tool"
        echo "  ffmpeg"
        echo "  jq"
        exit 1
    fi
    set -e
}

# Detect HDR
detect_hdr() {
    # FFprobe all metadata for the file
    local probe=$(
        ffprobe -hide_banner \
            -loglevel warning \
            -select_streams v \
            -print_format json \
            -show_frames \
            -read_intervals "%+#1" \
            -show_entries "frame=color_space,color_primaries,color_transfer,side_data_list,pix_fmt" \
            -i "$VIDFILE" \
            2>/dev/null
    )

    # Isolate the types of sidedata we have
    local sidedata=$(
        echo "$probe" | jq \
            '.frames[].side_data_list[].side_data_type' \
            2>/dev/null
    )

    set +e

    # Do we have HDR10 metadata?
    echo "$sidedata" | grep "Mastering display metadata" >/dev/null
    if [ $? -eq 0 ]; then
        # Grab basic mastering info
        HDR_PIXEL_FORMAT=$(echo $probe | jq -r '.frames[].pix_fmt')
        HDR_COLOR_SPACE=$(echo $probe | jq -r '.frames[].color_space')
        HDR_COLOR_PRIMARIES=$(echo $probe | jq -r '.frames[].color_primaries')
        HDR_COLOR_TRANSFER=$(echo $probe | jq -r '.frames[].color_transfer')

        # Grab mastering metadata
        # This is a heck of a jq command, so break it up to make it easy to read
        local jq_data=' .frames[].side_data_list[]'
        local jq_meta=' | select(.side_data_type | strings | test("Mastering display metadata"))'
        local jq_map=' | to_entries|map("HDR_\(.key | ascii_upcase)=\"\(.value|tostring)\"")|.[]'

        local hdrvars=$(echo $probe | jq -r "${jq_data}${jq_meta}${jq_map}")

        if [ $? -ne 0 ]; then
            echo "ERROR: Couldn't read HDR10 metadata"
            exit 1
        fi
        eval $hdrvars
    fi

    # Do we have HDR10+ metadata?
    echo "$sidedata" | grep "HDR Dynamic Metadata" >/dev/null
    if [ $? -eq 0 ]; then
        FOUND_HDR10PLUS=1
    fi

    # Do we have Dolby Vision metadata?
    echo "$sidedata" | grep "Dolby Vision Metadata" >/dev/null
    if [ $? -eq 0 ]; then
        FOUND_DOVI=1
    fi

    set -e
}

# Try to autodetect whether we need to crop the video
detect_crop() {
    # Detect crop
    local duration=$(
        printf "%.0f\n" $(
            ffprobe \
                -v quiet \
                -show_entries format=duration \
                -hide_banner \
                -of default=noprint_wrappers=1:nokey=1 \
                -i "$VIDFILE"
            )
    )
    SETTINGS_CROP=$(
        ffmpeg \
            -i "$VIDFILE" \
            -ss $((duration/10)) -t 10 \
            -vf cropdetect \
            -f null \
            - 2>&1 \
            | awk '/crop/ { print $NF }' \
            | tail -1
    )

    # Separate out the crop values
    if [[ "$SETTINGS_CROP" =~ crop=([0-9]+):([0-9]+):([0-9]+):([0-9]+) ]]; then
        local x="${BASH_REMATCH[1]}"
        local y="${BASH_REMATCH[2]}"
        local offset_x="${BASH_REMATCH[3]}"
        local offset_y="${BASH_REMATCH[4]}"

        # If the offsets are low enough, don't crop
        if [ "$offset_x" -le 8 ]; then
            x=$((x+(offset_x*2)))
            offset_x=0
        fi
        if [ "$offset_y" -le 8 ]; then
            y=$((y+(offset_y*2)))
            offset_y=0
        fi

        # Reassemble if we want to crop
        if [ "$offset_x" -eq 0 ] && [ "$offset_y" -eq 0 ]; then
            SETTINGS_CROP=''
        else
            SETTINGS_CROP="crop=${x}:${y}:${offset_x}:${offset_y}"
        fi
    fi
}

main() {
    # Sanity checks
    check_requirements
    check_file

    # Analysis
    detect_hdr
    detect_crop
}

main
